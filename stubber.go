// Stubber is a tool to automate the creation of "stubbed" interface implementations.
//
// An interface's stubbed implementation is a struct, satisfying the interface,
// that contains one field for each of the interface's methods. When one of
// these methods is called, it uses the backing field as its implementation, or
// panics if none was defined. This allows the behavior of the stub to be
// modified at run-time in a type-safe way, while only requiring you to define
// the methods that will actually be called.
//
// For example, given this simple interface:
//
//	type SessionManager interface {
//		CurrentUser() (int64, error)
//	}
//
// Then its stub would look like this:
//
//	type StubbedSessionManager struct {
//		CurrentUserStub func() (int64, error)
//	}
//
//	func (s *StubbedSessionManager) CurrentUser() (int64, error) {
//		if s.CurrentUserStub == nil {
//			panic("StubbedSessionManager.CurrentUser: nil method stub")
//		}
//		return (s.CurrentUserStub)()
//	}
//
// Note that StubbedSessionManager implements the SessionManager interface, and that its
// implementation of the UserName method uses the backing field CurrentUserStub.
//
// Here's an example of how it would be used in a test:
//
//	func TestSomething(t *testing.T) {
//		sm := &StubbedSessionManager{
//			CurrentUserStub: func() (int64, error) {
//				return 0, nil // or whatever implementation you want
//			},
//		}
//
//		// Use sm here anywhere a SessionManager is accepted
//	}
//
// Assuming the rest of your code is built around an actual implementation of
// SessionManager, and that your methods take their dependent resources as
// parameters, then this provides an easy way to mock out service calls, but
// in an easy-to-understand, type-safe manner.
//
// See the example folder for more information.
//
// TODO: record method calls with their arguments in each stub implementation
package main

import (
	"bytes"
	"flag"
	"go/ast"
	"go/build"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"html/template"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"unicode"

	"golang.org/x/tools/imports"
)

var (
	t = template.Must(template.New("").Parse(`// This file was generated by stubber; DO NOT EDIT
	
package {{.PackageName}}

{{range $interface := .Interfaces}}
type {{.ImplName}} struct {
	{{range .Funcs -}}
	{{.StubName}} func({{.ParamsString}}) {{.ResultsString}}
	{{.CallsName false}} []{{.ParamsStruct}}
	{{end}}
}

{{range .Funcs}}
func (s *{{$interface.ImplName}}) {{.Name}}({{.ParamsString}}) {{.ResultsString}} {
	if s.{{.StubName}} == nil {
		panic("{{$interface.ImplName}}.{{.Name}}: nil method stub")
	}
	s.{{.CallsName false}} = append(s.{{.CallsName false}}, {{.ParamsStruct}}{ {{.ParamsStructValues}} })
	{{if .HasResults}}return {{end}}(s.{{.StubName}})({{.ParamNames}})
}

func (s *{{$interface.ImplName}}) {{.CallsName true}}() []{{.ParamsStruct}} {
	return s.{{.CallsName false}}
}
{{end}}

// Compile-time check that the implementation matches the interface.
var _ {{.Name}} = (*{{.ImplName}})(nil)
{{end}}
`))
)

func main() {
	var (
		typeNames = flag.String("types", "", "comma-separated list of type names; defaults to all interfaces")
		stdout    = flag.Bool("stdout", false, "write result to stdout")
	)

	log.SetFlags(0)
	log.SetPrefix("stubber: ")
	flag.Parse()

	var types []string
	if *typeNames != "" {
		types = strings.Split(*typeNames, ",")
	}

	// Default to the current directory, but grab the first argument as the dir if it's available.
	dir := "."
	if args := flag.Args(); len(args) > 0 {
		dir = args[0]
	}

	var out io.Writer
	if *stdout {
		out = os.Stdout
	}

	Main(types, dir, out)
}

func Main(types []string, dir string, out io.Writer) {
	pkg := NewPackage(dir)
	pkg.Check(types)

	var buf bytes.Buffer
	for filename, interfaces := range pkg.Defs {
		buf.Reset()
		if err := t.Execute(&buf, struct {
			PackageName string
			Interfaces  []Interface
		}{
			PackageName: pkg.Name,
			Interfaces:  interfaces,
		}); err != nil {
			log.Fatal(err)
		}

		newFilename := filename[:len(filename)-3] + "_stubs.go"
		code, err := imports.Process(newFilename, buf.Bytes(), nil)
		if err != nil {
			log.Print(buf.String())
			log.Fatalf("cannot process imports: %s", err)
		}

		if out != nil {
			if _, err := out.Write(code); err != nil {
				log.Fatal("failed to write result: %s", err)
			}
		} else {
			if err := ioutil.WriteFile(newFilename, code, 0644); err != nil {
				log.Fatalf("failed to write output file %s: %s", newFilename, err)
			}
		}
	}
}

type Package struct {
	dir   string
	files []File
	fs    *token.FileSet

	Name string
	Defs map[string][]Interface
}

type File struct {
	f    *ast.File
	name string
}

func NewPackage(directory string) *Package {
	pkg, err := build.Default.ImportDir(directory, 0)
	if err != nil {
		log.Fatalf("cannot process directory %s: %s", directory, err)
	}

	var files []File
	fs := token.NewFileSet()
	for _, name := range pkg.GoFiles {
		if strings.HasSuffix(name, "_stubs.go") {
			continue
		}
		fullName := filepath.Join(directory, name)
		parsed, err := parser.ParseFile(fs, fullName, nil, 0)
		if err != nil {
			log.Fatalf("cannot parse file %s: %s", fullName, err)
		}
		files = append(files, File{f: parsed, name: name})
	}

	if len(files) == 0 {
		log.Fatalf("%s: no buildable Go files", directory)
	}

	return &Package{
		dir:   directory,
		files: files,
		fs:    fs,
		Name:  pkg.Name,
	}
}

func (p *Package) Check(ts []string) {
	config := types.Config{Importer: importer.Default()}
	info := types.Info{}
	files := make([]*ast.File, 0, len(p.files))
	for _, f := range p.files {
		files = append(files, f.f)
	}
	if _, err := config.Check(p.dir, p.fs, files, &info); err != nil {
		log.Fatalf("cannot check package: %s", err)
	}
	p.Defs = make(map[string][]Interface)
	for _, f := range p.files {
		ast.Inspect(f.f, p.genDecl(f.name, ts))
	}
}

func (p *Package) genDecl(filename string, ts []string) func(ast.Node) bool {
	return func(node ast.Node) bool {
		if decl, ok := node.(*ast.GenDecl); ok && decl.Tok == token.TYPE {
			for _, spec := range decl.Specs {
				tspec := spec.(*ast.TypeSpec)
				itype, ok := tspec.Type.(*ast.InterfaceType)
				if !ok {
					continue
				}
				iface := Interface{Name: tspec.Name.Name}

				// If any type names were specified, make sure this type was included.
				if len(ts) > 0 {
					var include bool
					for _, typ := range ts {
						if typ == iface.Name {
							include = true
							break
						}
					}
					if !include {
						continue
					}
				}

				for _, method := range itype.Methods.List {
					ftype, ok := method.Type.(*ast.FuncType)
					if !ok {
						continue
					}

					ifunc := Func{Name: method.Names[0].Name}
					if ifunc.Name == "_" {
						continue
					}

					if ftype.Params != nil {
						for _, param := range ftype.Params.List {
							v := Var{Type: typeName(param.Type)}
							if len(param.Names) > 0 {
								v.Name = param.Names[0].Name
							}
							ifunc.Params = append(ifunc.Params, v)
						}
					}

					if ftype.Results != nil {
						for _, result := range ftype.Results.List {
							v := Var{Type: typeName(result.Type)}
							if len(result.Names) > 0 {
								v.Name = result.Names[0].Name
							}
							ifunc.Results = append(ifunc.Results, v)
						}
					}

					iface.Funcs = append(iface.Funcs, ifunc)
				}
				p.Defs[filename] = append(p.Defs[filename], iface)
			}
		}
		return true
	}
}

type Interface struct {
	Name  string
	Funcs []Func
}

func (i *Interface) ImplName() string {
	return "Stubbed" + i.Name
}

type Func struct {
	Name    string
	Params  []Var
	Results []Var
}

func (f *Func) StubName() string {
	return f.Name + "Stub"
}

func (f *Func) CallsName(public bool) string {
	if public {
		return f.Name + "Calls"
	}
	return string(unicode.ToLower(rune(f.Name[0]))) + f.Name[1:] + "Calls"
}

func (f *Func) ParamsString() string {
	return joinVars(f.Params, ", ", false)
}

func (f *Func) ParamsStruct() string {
	return "struct{" + joinVars(f.Params, "; ", true) + "}"
}

func (f *Func) ParamsStructValues() string {
	var buf bytes.Buffer
	for _, v := range f.Params {
		buf.WriteString(publicize(v.Name) + ": " + v.Name + ",")
	}
	return buf.String()
}

func (f *Func) ParamNames() string {
	parts := make([]string, 0, len(f.Params))
	for _, v := range f.Params {
		parts = append(parts, v.Name)
	}
	return strings.Join(parts, ", ")
}

func (f *Func) ResultsString() string {
	s := joinVars(f.Results, ", ", false)
	if len(f.Results) > 1 || (f.HasResults() && f.Results[0].Name != "") {
		s = "(" + s + ")"
	}
	return s
}

func (f *Func) HasResults() bool {
	return len(f.Results) > 0
}

type Var struct {
	Name string
	Type string
}

func joinVars(vars []Var, sep string, public bool) string {
	parts := make([]string, 0, len(vars))
	for _, v := range vars {
		name := v.Name
		if public {
			name = publicize(name)
		}
		parts = append(parts, name+" "+v.Type)
	}
	return strings.Join(parts, sep)
}

func typeName(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.ArrayType:
		if t.Len == nil {
			return "[]" + typeName(t.Elt)
		} else {
			log.Fatal("typeName: don't know how to handle non-slice arrays yet")
		}
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		return typeName(t.X) + "." + t.Sel.Name
	case *ast.StarExpr:
		return "*" + typeName(t.X)
	default:
		log.Fatalf("typeName: unknown node type: %T", t)
	}

	return ""
}

// TODO: improve this to make some variable names more readable, e.g. "db" -> "DB"
func publicize(name string) string {
	return string(unicode.ToTitle(rune(name[0]))) + name[1:]
}
