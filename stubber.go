// Stubber is a tool to automate the creation of "stubbed" interface implementations.
//
// An interface's stubbed implementation is a struct, satisfying the interface,
// that contains one field for each of the interface's methods. When one of
// these methods is called, it uses the backing field as its implementation, or
// panics if none was defined. This allows the behavior of the stub to be
// modified at run-time in a type-safe way, while only requiring you to define
// the methods that will actually be called.
//
// For example, given this simple interface:
//
//	type SessionManager interface {
//		GetUserID(db *sql.DB, username string) (int64, error)
//	}
//
// Then its stub would look like this:
//
//      type StubbedSessionManager struct {
//      	GetUserIDStub  func(db *sql.DB, username string) (int64, error)
//      	getUserIDCalls []struct {
//      		Db       *sql.DB
//      		Username string
//      	}
//      }
//
//      func (s *StubbedSessionManager) GetUserID(db *sql.DB, username string) (int64, error) {
//      	if s.GetUserIDStub == nil {
//      		panic("StubbedSessionManager.GetUserID: nil method stub")
//      	}
//      	s.getUserIDCalls = append(s.getUserIDCalls, struct {
//      		Db       *sql.DB
//      		Username string
//      	}{Db: db, Username: username})
//      	return (s.GetUserIDStub)(db, username)
//      }
//
//      func (s *StubbedSessionManager) GetUserIDCalls() []struct {
//      	Db       *sql.DB
//      	Username string
//      } {
//      	return s.getUserIDCalls
//      }
//
// Note that StubbedSessionManager implements the SessionManager interface, and that its
// implementation of GetUserID()  uses the backing field GetUserIDStub.
//
// Here's an example of how it would be used in a test:
//
//	func TestSomething(t *testing.T) {
//		sm := &StubbedSessionManager{
//			GetUserIDStub: func(db *sql.DB, username string) (int64, error) {
//				return 0, nil // or whatever implementation you want
//			},
//		}
//
//		// Use sm here anywhere a SessionManager is accepted
//	}
//
// Assuming the rest of your code is built around an actual implementation of
// SessionManager, and that your methods take their dependent resources as
// parameters, then this provides an easy way to mock out service calls, but
// in an easy-to-understand, type-safe manner.
//
// See the example folder for more information.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/token"
	"html/template"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"unicode"

	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/imports"
)

var (
	t = template.Must(template.New("").Parse(`
{{range $interface := .Interfaces}}
// {{.Name}} is a stubbed implementation of {{$.InputPackage.Name}}.{{.Name}}.
type {{.Name}} struct {
	{{range .Funcs -}}
	// {{.StubName}} defines the implementation for {{.Name}}.
	{{.StubName}} func({{.ParamsString}}) {{.ResultsString}}
	{{.CallsName false}} []{{.ParamsStruct}}
	{{end}}
}

{{range .Funcs}}
// {{.Name}} delegates its behavior to the field {{.StubName}}.
func (s *{{$interface.Name}}) {{.Name}}({{.ParamsString}}) {{.ResultsString}} {
	if s.{{.StubName}} == nil {
		panic("{{$interface.Name}}.{{.Name}}: nil method stub")
	}
	s.{{.CallsName false}} = append(s.{{.CallsName false}}, {{.ParamsStruct}}{ {{.ParamsStructValues}} })
	{{if .HasResults}}return {{end}}(s.{{.StubName}})({{.ParamNames}})
}

// {{.CallsName true}} returns a slice of calls made to {{.Name}}. Each element
// of the slice represents the parameters that were provided.
func (s *{{$interface.Name}}) {{.CallsName true}}() []{{.ParamsStruct}} {
	return s.{{.CallsName false}}
}
{{end}}

// Compile-time check that the implementation matches the interface.
var _ {{$.InputPackage.Name}}.{{.Name}} = (*{{.Name}})(nil)
{{end}}
`))
)

func main() {
	var (
		outputDir = flag.String("output", "", "path to output directory; '-' will write result to stdout")
	)

	log.SetFlags(0)
	log.SetPrefix("stubber: ")
	flag.Parse()

	var out io.Writer
	if *outputDir == "-" {
		out = os.Stdout
	}
	Main(flag.Args(), *outputDir, out)
}

func Main(inputs []string, outputDir string, out io.Writer) {
	pkgs, err := packages.Load(&packages.Config{Mode: packages.LoadSyntax}, inputs...)
	if err != nil {
		log.Fatal(err)
	}
	var buf bytes.Buffer
	buf.WriteString(`// This file was generated by stubber; DO NOT EDIT
	
package stubbed

`)

	/*
		buf.WriteString(`import (`)
		for _, pkg := range pkgs {
			buf.WriteString(`"` + ImportPath(pkg.PkgPath) + `"`)
		}

		buf.WriteString(")")
	*/

	for _, pkg := range pkgs {
		log.Printf("found package: %s", pkg.Name)
		if err := t.Execute(&buf, struct {
			InputPackage *packages.Package
			Interfaces   []Interface
		}{
			InputPackage: pkg,
			Interfaces:   FindInterfaces(pkg),
		}); err != nil {
			log.Fatal(err)
		}
	}

	filename := filepath.Join(outputDir, "stubbed.go")
	code, err := imports.Process(filename, buf.Bytes(), nil)
	if err != nil {
		log.Print(buf.String())
		log.Fatalf("cannot process imports: %s", err)
	}

	if out != nil {
		if _, err := out.Write(code); err != nil {
			log.Fatalf("failed to write result: %s", err)
		}
	} else {
		if err := ioutil.WriteFile(filename, code, 0644); err != nil {
			log.Fatalf("failed to write output file %s: %s", filename, err)
		}
	}
}

func FindInterfaces(pkg *packages.Package) []Interface {
	var interfaces []Interface
	for _, file := range pkg.Syntax {
		ast.Inspect(file, func(node ast.Node) bool {
			if decl, ok := node.(*ast.GenDecl); ok && decl.Tok == token.TYPE {
				for _, spec := range decl.Specs {
					if tspec, ok := spec.(*ast.TypeSpec); ok {
						if itype, ok := tspec.Type.(*ast.InterfaceType); ok {
							interfaces = append(interfaces, NewInterface(pkg, tspec, itype))
						}
					}
				}
			}
			return true
		})
	}
	return interfaces
}

func NewInterface(pkg *packages.Package, tspec *ast.TypeSpec, itype *ast.InterfaceType) Interface {
	iface := Interface{
		Pkg:  pkg,
		Name: tspec.Name.Name,
	}
	for _, method := range itype.Methods.List {
		ftype, ok := method.Type.(*ast.FuncType)
		if !ok {
			continue
		}
		name := method.Names[0].Name
		if name == "_" {
			continue
		}
		iface.Funcs = append(iface.Funcs, NewFunc(name, ftype))
	}
	return iface
}

func NewFunc(name string, ftype *ast.FuncType) Func {
	ifunc := Func{
		Name: name,
	}
	if ftype.Params != nil {
		for _, param := range ftype.Params.List {
			if len(param.Names) == 0 {
				ifunc.Params = append(ifunc.Params, Var{
					Type: TypeName(param.Type),
				})
			} else {
				for _, ident := range param.Names {
					ifunc.Params = append(ifunc.Params, Var{
						Type: TypeName(param.Type),
						Name: ident.Name,
					})
				}
			}
		}
	}

	if ftype.Results != nil {
		for _, result := range ftype.Results.List {
			if len(result.Names) == 0 {
				ifunc.Results = append(ifunc.Results, Var{Type: TypeName(result.Type)})
			} else {
				for _, ident := range result.Names {
					ifunc.Results = append(ifunc.Results, Var{
						Type: TypeName(result.Type),
						Name: ident.Name,
					})
				}
			}
		}
	}
	return ifunc
}

func ImportPath(pkgPath string) string {
	parts := strings.Split(pkgPath, "/")
	for len(parts) > 0 {
		path := strings.Join(parts, "/")
		if _, err := packages.Load(nil, path); err == nil {
			log.Println("package " + pkgPath + " successfully imported")
			return path
		}
		parts = parts[1:]
	}
	log.Fatal("unable to import package: " + pkgPath)
	return ""
}

func TypeName(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.ArrayType:
		if t.Len == nil {
			return "[]" + TypeName(t.Elt)
		} else {
			log.Fatal("Package.TypeName: don't know how to handle non-slice arrays yet")
		}

	case *ast.Ident:
		/*
			if p.External && p.Scope.Lookup(t.Name) != nil {
				return p.InputName + "." + t.Name
			}
		*/
		return t.Name

	case *ast.SelectorExpr:
		return TypeName(t.X) + "." + t.Sel.Name

	case *ast.StarExpr:
		return "*" + TypeName(t.X)

	case *ast.MapType:
		return "map[" + TypeName(t.Key) + "]" + TypeName(t.Value)

	case *ast.InterfaceType:
		if t.Methods != nil && len(t.Methods.List) > 0 {
			log.Fatalf("Package.TypeName: does not currently support non-empty interface literal")
		}
		return "interface{}"

	case *ast.Ellipsis:
		return "..." + TypeName(t.Elt)

	case *ast.FuncType:
		var (
			params  = FieldListString(t.Params)
			results = FieldListString(t.Results)
		)
		return fmt.Sprintf("func(%s) (%s)", params, results)

	default:
		log.Fatalf("Package.TypeName: unknown node type: %T", t)
	}

	return ""
}

func FieldListString(fl *ast.FieldList) string {
	var values []string
	for _, field := range fl.List {
		var names []string
		for _, name := range field.Names {
			names = append(names, name.Name)
		}
		values = append(values, strings.Join(names, ", ")+" "+TypeName(field.Type))
	}
	return strings.Join(values, ", ")
}

type Interface struct {
	Pkg   *packages.Package
	Name  string
	Funcs []Func
}

type Func struct {
	Name    string
	Params  []Var
	Results []Var
}

func (f *Func) StubName() string {
	return f.Name + "Stub"
}

func (f *Func) CallsName(public bool) string {
	if public {
		return f.Name + "Calls"
	}
	return string(unicode.ToLower(rune(f.Name[0]))) + f.Name[1:] + "Calls"
}

func (f *Func) ParamsString() string {
	return joinVars(f.Params, ", ", false, false)
}

func (f *Func) ParamsStruct() string {
	return "struct{" + joinVars(f.Params, "; ", true, true) + "}"
}

func (f *Func) ParamsStructValues() string {
	var buf bytes.Buffer
	for _, v := range f.Params {
		buf.WriteString(publicize(v.Name) + ": " + v.Name + ",")
	}
	return buf.String()
}

func (f *Func) ParamNames() string {
	parts := make([]string, 0, len(f.Params))
	for _, v := range f.Params {
		name := v.Name
		if isVariadic(v.Type) {
			name = name + "..."
		}
		parts = append(parts, name)
	}
	return strings.Join(parts, ", ")
}

func (f *Func) ResultsString() string {
	s := joinVars(f.Results, ", ", false, false)
	if len(f.Results) > 1 || (f.HasResults() && f.Results[0].Name != "") {
		s = "(" + s + ")"
	}
	return s
}

func (f *Func) HasResults() bool {
	return len(f.Results) > 0
}

type Var struct {
	Name string
	Type string
}

func joinVars(vars []Var, sep string, public, inStruct bool) string {
	parts := make([]string, 0, len(vars))
	for _, v := range vars {
		name, typ := v.Name, v.Type
		if public {
			name = publicize(name)
		}
		if inStruct && isVariadic(v.Type) {
			typ = "[]" + v.Type[3:]
		}
		parts = append(parts, name+" "+typ)
	}
	return strings.Join(parts, sep)
}

func typeName(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.ArrayType:
		if t.Len == nil {
			return "[]" + typeName(t.Elt)
		} else {
			log.Fatal("typeName: don't know how to handle non-slice arrays yet")
		}
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		return typeName(t.X) + "." + t.Sel.Name
	case *ast.StarExpr:
		return "*" + typeName(t.X)
	default:
		log.Fatalf("typeName: unknown node type: %T", t)
	}

	return ""
}

// TODO: improve this to make some variable names more readable, e.g. "db" -> "DB"
func publicize(name string) string {
	return string(unicode.ToTitle(rune(name[0]))) + name[1:]
}

func isVariadic(typ string) bool {
	return strings.HasPrefix(typ, "...")
}
