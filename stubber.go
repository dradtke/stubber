// Stubber is a tool to automate the creation of "stubbed" interface implementations.
//
// An interface's stubbed implementation is a struct, satisfying the interface,
// that contains one field for each of the interface's methods. When one of
// these methods is called, it uses the backing field as its implementation, or
// panics if none was defined. This allows the behavior of the stub to be
// modified at run-time in a type-safe way, while only requiring you to define
// the methods that will actually be called.
//
// For example, given this simple interface:
//
//	type SessionManager interface {
//		CurrentUser() (int64, error)
//	}
//
// Then its stub would look like this:
//
//	type StubbedSessionManager struct {
//		CurrentUserStub func() (int64, error)
//	}
//
//	func (s *StubbedSessionManager) CurrentUser() (int64, error) {
//		if s.CurrentUserStub == nil {
//			panic("StubbedSessionManager.CurrentUser: nil method stub")
//		}
//		return (s.CurrentUserStub)()
//	}
//
// Note that StubbedSessionManager implements the SessionManager interface, and that its
// implementation of the UserName method uses the backing field CurrentUserStub.
//
// Here's an example of how it would be used in a test:
//
//	func TestSomething(t *testing.T) {
//		sm := &StubbedSessionManager{
//			CurrentUserStub: func() (int64, error) {
//				return 0, nil // or whatever implementation you want
//			},
//		}
//
//		// Use sm here anywhere a SessionManager is accepted
//	}
//
// Assuming the rest of your code is built around an actual implementation of
// SessionManager, and that your methods take their dependent resources as
// parameters, then this provides an easy way to mock out service calls, but
// in an easy-to-understand, type-safe manner.
//
// See the example folder for more information.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/build"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"html/template"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/tools/imports"
)

var (
	typeNames = flag.String("types", "", "comma-separated list of type names; defaults to all interfaces")
	output    = flag.String("output", "", "path to output directory; package name will be inferred from its name")

	t = template.Must(template.New("").Parse(`// This file was generated by stubber; DO NOT EDIT
	
package {{.Package.OutputName}}

{{range $interface := .Interfaces}}
type {{.ImplName}} struct {
	{{range .Funcs -}}
	{{.StubName}} func({{.ParamsString}}) {{.ResultsString}}
	{{end}}
}

{{range .Funcs}}
func (s *{{$interface.ImplName}}) {{.Name}}({{.ParamsString}}) {{.ResultsString}} {
	if s.{{.StubName}} == nil {
		panic("{{$interface.ImplName}}.{{.Name}}: nil method stub")
	}
	{{if .HasResults}}return {{end}}(s.{{.StubName}})({{.ParamNames}})
}
{{end}}

// Compile-time check that the implementation matches the interface.
var _ {{if $.Package.External}}{{$.Package.InputName}}.{{end}}{{.Name}} = (*{{.ImplName}})(nil)
{{end}}
`))
)

func main() {
	log.SetFlags(0)
	log.SetPrefix("stubber: ")
	flag.Parse()

	var ts []string
	if *typeNames != "" {
		ts = strings.Split(*typeNames, ",")
	}

	// Default to the current directory, but grab the first argument as the dir if it's available.
	inputDir := "."
	if args := flag.Args(); len(args) > 0 {
		inputDir = args[0]
	}

	inputDirInfo, err := os.Stat(inputDir)
	if err != nil {
		log.Fatalf("cannot stat input dir: %s", err)
	}

	outputDir := inputDir
	if *output != "" {
		if outputDir, err = filepath.Rel(inputDir, *output); err != nil {
			log.Fatalf("cannot calculate output dir: %s", err)
		}
		if err := os.MkdirAll(outputDir, inputDirInfo.Mode()); err != nil {
			log.Fatalf("cannot make output directory: %s", err)
		}
	}

	pkg := NewPackage(inputDir, outputDir)
	pkg.Check(ts)

	var buf bytes.Buffer
	for filename, interfaces := range pkg.Defs {
		buf.Reset()
		if err := t.Execute(&buf, struct {
			Package    *Package
			Interfaces []Interface
		}{
			Package:    pkg,
			Interfaces: interfaces,
		}); err != nil {
			log.Fatal(err)
		}

		newFilename := filename[:len(filename)-3] + "_stubs.go"
		code, err := imports.Process(newFilename, buf.Bytes(), nil)
		if err != nil {
			fmt.Println(buf.String())
			log.Fatalf("cannot process imports: %s", err)
		}

		output := filepath.Join(outputDir, newFilename)
		if err := ioutil.WriteFile(output, code, 0644); err != nil {
			log.Fatalf("cannot write file %s: %s", output, err)
		}
	}
}

type Package struct {
	dir   string
	files map[string]*ast.File
	fs    *token.FileSet
	// OutputName is the name of the output package.
	OutputName string
	// InputName is the name of the input package.
	InputName string
	// External is true if the output is in a different package than the
	// input, indicating that the interface name needs to be qualified if
	// referenced.
	External bool
	Scope    *types.Scope
	Defs     map[string][]Interface
}

func NewPackage(inputDir, outputDir string) *Package {
	pkg, err := build.Default.ImportDir(inputDir, 0)
	if err != nil {
		log.Fatalf("cannot process directory %s: %s", inputDir, err)
	}

	files := make(map[string]*ast.File)
	fs := token.NewFileSet()
	for _, name := range pkg.GoFiles {
		if strings.HasSuffix(name, "_stubs.go") {
			continue
		}
		fullName := filepath.Join(inputDir, name)
		parsed, err := parser.ParseFile(fs, fullName, nil, 0)
		if err != nil {
			log.Fatalf("cannot parse file %s: %s", fullName, err)
		}
		files[name] = parsed
	}

	if len(files) == 0 {
		log.Fatalf("%s: no buildable Go files", inputDir)
	}

	p := &Package{
		dir:        inputDir,
		files:      files,
		fs:         fs,
		InputName:  pkg.Name,
		OutputName: pkg.Name,
	}

	if outputDir != inputDir {
		p.OutputName = filepath.Base(outputDir)
		p.External = true
	}

	return p
}

func (p *Package) TypeName(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.ArrayType:
		if t.Len == nil {
			return "[]" + p.TypeName(t.Elt)
		} else {
			log.Fatal("Package.TypeName: don't know how to handle non-slice arrays yet")
		}

	case *ast.Ident:
		if p.External && p.Scope.Lookup(t.Name) != nil {
			return p.InputName + "." + t.Name
		}
		return t.Name

	case *ast.SelectorExpr:
		return p.TypeName(t.X) + "." + t.Sel.Name

	case *ast.StarExpr:
		return "*" + p.TypeName(t.X)

	case *ast.MapType:
		return "map[" + p.TypeName(t.Key) + "]" + p.TypeName(t.Value)

	default:
		log.Fatalf("Package.TypeName: unknown node type: %T", t)
	}

	return ""
}

func (p *Package) Check(ts []string) {
	config := types.Config{Importer: importer.Default()}
	info := types.Info{}
	files := make([]*ast.File, 0, len(p.files))
	for _, f := range p.files {
		files = append(files, f)
	}
	pkg, err := config.Check(p.dir, p.fs, files, &info)
	if err != nil {
		log.Fatalf("cannot check package: %s", err)
	}
	p.Defs = make(map[string][]Interface)
	p.Scope = pkg.Scope()
	for filename, f := range p.files {
		ast.Inspect(f, p.genDecl(filename, ts))
	}
}

func (p *Package) genDecl(filename string, ts []string) func(ast.Node) bool {
	return func(node ast.Node) bool {
		if decl, ok := node.(*ast.GenDecl); ok && decl.Tok == token.TYPE {
			for _, spec := range decl.Specs {
				tspec := spec.(*ast.TypeSpec)
				itype, ok := tspec.Type.(*ast.InterfaceType)
				if !ok {
					continue
				}
				iface := Interface{Name: tspec.Name.Name}

				// If any type names were specified, make sure this type was included.
				if len(ts) > 0 {
					var include bool
					for _, typ := range ts {
						if typ == iface.Name {
							include = true
							break
						}
					}
					if !include {
						continue
					}
				}

				for _, method := range itype.Methods.List {
					ftype, ok := method.Type.(*ast.FuncType)
					if !ok {
						continue
					}

					ifunc := Func{Name: method.Names[0].Name}
					if ifunc.Name == "_" {
						continue
					}

					if ftype.Params != nil {
						for _, param := range ftype.Params.List {
							if len(param.Names) == 0 {
								ifunc.Params = append(ifunc.Params, Var{
									Type: p.TypeName(param.Type),
								})
							} else {
								for _, ident := range param.Names {
									ifunc.Params = append(ifunc.Params, Var{
										Type: p.TypeName(param.Type),
										Name: ident.Name,
									})
								}
							}
						}
					}

					if ftype.Results != nil {
						for _, result := range ftype.Results.List {
							if len(result.Names) == 0 {
								ifunc.Results = append(ifunc.Results, Var{Type: p.TypeName(result.Type)})
							} else {
								for _, ident := range result.Names {
									ifunc.Results = append(ifunc.Results, Var{
										Type: p.TypeName(result.Type),
										Name: ident.Name,
									})
								}
							}
						}
					}

					iface.Funcs = append(iface.Funcs, ifunc)
				}
				p.Defs[filename] = append(p.Defs[filename], iface)
			}
		}
		return true
	}
}

type Interface struct {
	Name, QualifiedName string
	Funcs               []Func
}

func (i *Interface) ImplName() string {
	return "Stubbed" + i.Name
}

type Func struct {
	Name    string
	Params  []Var
	Results []Var
}

func (f *Func) StubName() string {
	return f.Name + "Stub"
}

func (f *Func) ParamsString() string {
	return joinVars(f.Params)
}

func (f *Func) ParamNames() string {
	parts := make([]string, 0, len(f.Params))
	for _, v := range f.Params {
		parts = append(parts, v.Name)
	}
	return strings.Join(parts, ", ")
}

func (f *Func) ResultsString() string {
	s := joinVars(f.Results)
	if len(f.Results) > 1 || (f.HasResults() && f.Results[0].Name != "") {
		s = "(" + s + ")"
	}
	return s
}

func (f *Func) HasResults() bool {
	return len(f.Results) > 0
}

type Var struct {
	Name string
	Type string
}

func joinVars(vars []Var) string {
	parts := make([]string, 0, len(vars))
	for _, v := range vars {
		parts = append(parts, v.Name+" "+v.Type)
	}
	return strings.Join(parts, ", ")
}
