// Stubber is a tool to automate the creation of "stubbed" interface implementations.
//
// An interface's stubbed implementation is a struct, satisfying the interface,
// that contains one field for each of the interface's methods. When one of
// these methods is called, it uses the backing field as its implementation, or
// panics if none was defined. This allows the behavior of the stub to be
// modified at run-time in a type-safe way, while only requiring you to define
// the methods that will actually be called.
//
// For example, given this simple interface:
//
//	type SessionManager interface {
//		GetUserID(db *sql.DB, username string) (int64, error)
//	}
//
// Then its stub would look like this:
//
//      type StubbedSessionManager struct {
//      	GetUserIDStub  func(db *sql.DB, username string) (int64, error)
//      	getUserIDCalls []struct {
//      		Db       *sql.DB
//      		Username string
//      	}
//      }
//
//      func (s *StubbedSessionManager) GetUserID(db *sql.DB, username string) (int64, error) {
//      	if s.GetUserIDStub == nil {
//      		panic("StubbedSessionManager.GetUserID: nil method stub")
//      	}
//      	s.getUserIDCalls = append(s.getUserIDCalls, struct {
//      		Db       *sql.DB
//      		Username string
//      	}{Db: db, Username: username})
//      	return (s.GetUserIDStub)(db, username)
//      }
//
//      func (s *StubbedSessionManager) GetUserIDCalls() []struct {
//      	Db       *sql.DB
//      	Username string
//      } {
//      	return s.getUserIDCalls
//      }
//
// Note that StubbedSessionManager implements the SessionManager interface, and that its
// implementation of GetUserID()  uses the backing field GetUserIDStub.
//
// Here's an example of how it would be used in a test:
//
//	func TestSomething(t *testing.T) {
//		sm := &StubbedSessionManager{
//			GetUserIDStub: func(db *sql.DB, username string) (int64, error) {
//				return 0, nil // or whatever implementation you want
//			},
//		}
//
//		// Use sm here anywhere a SessionManager is accepted
//	}
//
// Assuming the rest of your code is built around an actual implementation of
// SessionManager, and that your methods take their dependent resources as
// parameters, then this provides an easy way to mock out service calls, but
// in an easy-to-understand, type-safe manner.
//
// See the example folder for more information.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/token"
	"go/types"
	"html/template"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"unicode"

	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/imports"
)

var (
	t = template.Must(template.New("").Parse(`
{{range $interface := .Interfaces}}
// {{.DstName}} is a stubbed implementation of {{$.InputPackage.Name}}.{{.SrcName}}.
type {{.DstName}} struct {
	{{range .Funcs -}}
	// {{.StubName}} defines the implementation for {{.Name}}.
	{{.StubName}} func({{.ParamsString}}) {{.ResultsString}}
	{{.CallsName false}} []{{.ParamsStruct}}
	{{end}}
}

{{range .Funcs}}
// {{.Name}} delegates its behavior to the field {{.StubName}}.
func (s *{{$interface.DstName}}) {{.Name}}({{.ParamsString}}) {{.ResultsString}} {
	if s.{{.StubName}} == nil {
		panic("{{$interface.DstName}}.{{.Name}}: nil method stub")
	}
	s.{{.CallsName false}} = append(s.{{.CallsName false}}, {{.ParamsStruct}}{ {{.ParamsStructValues}} })
	{{if .HasResults}}return {{end}}(s.{{.StubName}})({{.ParamNames}})
}

// {{.CallsName true}} returns a slice of calls made to {{.Name}}. Each element
// of the slice represents the parameters that were provided.
func (s *{{$interface.DstName}}) {{.CallsName true}}() []{{.ParamsStruct}} {
	return s.{{.CallsName false}}
}
{{end}}

// Compile-time check that the implementation matches the interface.
var _ {{$.InputPackage.Name}}.{{.SrcName}} = (*{{.DstName}})(nil)
{{end}}
`))
)

func main() {
	var (
		outputDir = flag.String("output", "", "path to output directory; '-' will write result to stdout")
	)

	log.SetFlags(0)
	log.SetPrefix("stubber: ")
	flag.Parse()

	var out io.Writer
	if *outputDir == "-" {
		out = os.Stdout
	} else {
		if err := os.MkdirAll(*outputDir, 0755); err != nil {
			log.Fatalf("failed to create output directory '%s': %s", *outputDir, err)
		}
	}
	Main(flag.Args(), *outputDir, out)
}

func Main(inputs []string, outputDir string, out io.Writer) {
	outputPkgName := filepath.Base(outputDir)
	if out != nil {
		outputPkgName = "out"
	}

	pkgs, err := packages.Load(&packages.Config{Mode: packages.LoadSyntax}, inputs...)
	if err != nil {
		log.Fatal(err)
	}
	var buf bytes.Buffer
	buf.WriteString("// This file was generated by stubber; DO NOT EDIT\n\n")
	buf.WriteString("package " + outputPkgName + "\n\n")

	dstNameCount := make(map[string]int)
	allInterfaces := make(map[*packages.Package][]*Interface)

	for _, pkg := range pkgs {
		ifaces := FindInterfaces(pkg)
		for _, iface := range ifaces {
			dstNameCount[iface.DstName] = dstNameCount[iface.DstName] + 1
		}
		allInterfaces[pkg] = ifaces
	}

	RenameCollisions(allInterfaces, dstNameCount)

	for pkg, ifaces := range allInterfaces {
		if err := t.Execute(&buf, struct {
			InputPackage *packages.Package
			Interfaces   []*Interface
		}{
			InputPackage: pkg,
			Interfaces:   ifaces,
		}); err != nil {
			log.Fatal(err)
		}
	}

	filename := filepath.Join(outputDir, filepath.Base(outputDir)+".go")
	if out != nil {
		filename = "out.go"
	}
	code, err := imports.Process(filename, buf.Bytes(), nil)
	if err != nil {
		log.Print(buf.String())
		log.Fatalf("cannot process imports: %s", err)
	}

	if out != nil {
		if _, err := out.Write(code); err != nil {
			log.Fatalf("failed to write result: %s", err)
		}
	} else {
		if err := ioutil.WriteFile(filename, code, 0644); err != nil {
			log.Fatalf("failed to write output file %s: %s", filename, err)
		}
	}
}

func FindInterfaces(pkg *packages.Package) []*Interface {
	var interfaces []*Interface
	for _, file := range pkg.Syntax {
		ast.Inspect(file, func(node ast.Node) bool {
			if decl, ok := node.(*ast.GenDecl); ok && decl.Tok == token.TYPE {
				for _, spec := range decl.Specs {
					if tspec, ok := spec.(*ast.TypeSpec); ok {
						if itype, ok := tspec.Type.(*ast.InterfaceType); ok {
							interfaces = append(interfaces, NewInterface(pkg, tspec, itype))
						}
					}
				}
			}
			return true
		})
	}
	return interfaces
}

func NewInterface(pkg *packages.Package, tspec *ast.TypeSpec, itype *ast.InterfaceType) *Interface {
	iface := &Interface{
		Pkg:     pkg,
		SrcName: tspec.Name.Name,
		DstName: tspec.Name.Name,
	}
	for _, method := range itype.Methods.List {
		ftype, ok := method.Type.(*ast.FuncType)
		if !ok {
			continue
		}
		name := method.Names[0].Name
		if name == "_" {
			continue
		}
		iface.Funcs = append(iface.Funcs, NewFunc(pkg, name, ftype))
	}
	return iface
}

func NewFunc(pkg *packages.Package, name string, ftype *ast.FuncType) Func {
	ifunc := Func{
		Name: name,
	}
	if ftype.Params != nil {
		for _, param := range ftype.Params.List {
			if len(param.Names) == 0 {
				ifunc.Params = append(ifunc.Params, Var{
					Type: TypeName(pkg, param.Type),
				})
			} else {
				for _, ident := range param.Names {
					ifunc.Params = append(ifunc.Params, Var{
						Type: TypeName(pkg, param.Type),
						Name: ident.Name,
					})
				}
			}
		}
	}

	if ftype.Results != nil {
		for _, result := range ftype.Results.List {
			if len(result.Names) == 0 {
				ifunc.Results = append(ifunc.Results, Var{Type: TypeName(pkg, result.Type)})
			} else {
				for _, ident := range result.Names {
					ifunc.Results = append(ifunc.Results, Var{
						Type: TypeName(pkg, result.Type),
						Name: ident.Name,
					})
				}
			}
		}
	}
	return ifunc
}

func ImportPath(pkgPath string) string {
	parts := strings.Split(pkgPath, "/")
	for len(parts) > 0 {
		path := strings.Join(parts, "/")
		if _, err := packages.Load(nil, path); err == nil {
			log.Println("package " + pkgPath + " successfully imported")
			return path
		}
		parts = parts[1:]
	}
	log.Fatal("unable to import package: " + pkgPath)
	return ""
}

func TypeName(pkg *packages.Package, expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.ArrayType:
		if t.Len == nil {
			return "[]" + TypeName(pkg, t.Elt)
		} else {
			log.Fatal("Package.TypeName: don't know how to handle non-slice arrays yet")
		}

	case *ast.Ident:
		// If the identifier represents a value defined within this package,
		// the output needs to qualify the tpye with the package name.
		ob := pkg.TypesInfo.Uses[t]
		if ob != nil {
			if named, ok := ob.Type().(*types.Named); ok && named.Obj().Pkg() == pkg.Types {
				return pkg.Name + "." + t.Name
			}
		}
		return t.Name

	case *ast.SelectorExpr:
		return TypeName(pkg, t.X) + "." + t.Sel.Name

	case *ast.StarExpr:
		return "*" + TypeName(pkg, t.X)

	case *ast.MapType:
		return "map[" + TypeName(pkg, t.Key) + "]" + TypeName(pkg, t.Value)

	case *ast.InterfaceType:
		if t.Methods != nil && len(t.Methods.List) > 0 {
			log.Fatalf("Package.TypeName: does not currently support non-empty interface literal")
		}
		return "interface{}"

	case *ast.Ellipsis:
		return "..." + TypeName(pkg, t.Elt)

	case *ast.FuncType:
		var (
			params  = FieldListString(pkg, t.Params)
			results = FieldListString(pkg, t.Results)
		)
		return fmt.Sprintf("func(%s) (%s)", params, results)

	default:
		log.Fatalf("Package.TypeName: unknown node type: %T", t)
	}

	return ""
}

func FieldListString(pkg *packages.Package, fl *ast.FieldList) string {
	var values []string
	for _, field := range fl.List {
		var names []string
		for _, name := range field.Names {
			names = append(names, name.Name)
		}
		values = append(values, strings.Join(names, ", ")+" "+TypeName(pkg, field.Type))
	}
	return strings.Join(values, ", ")
}

type Interface struct {
	Pkg              *packages.Package
	SrcName, DstName string
	Funcs            []Func
}

type Func struct {
	Name    string
	Params  []Var
	Results []Var
}

func (f *Func) StubName() string {
	return f.Name + "Stub"
}

func (f *Func) CallsName(public bool) string {
	if public {
		return f.Name + "Calls"
	}
	return string(unicode.ToLower(rune(f.Name[0]))) + f.Name[1:] + "Calls"
}

func (f *Func) ParamsString() string {
	return joinVars(f.Params, ", ", false, false)
}

func (f *Func) ParamsStruct() string {
	return "struct{" + joinVars(f.Params, "; ", true, true) + "}"
}

func (f *Func) ParamsStructValues() string {
	var buf bytes.Buffer
	for _, v := range f.Params {
		buf.WriteString(publicize(v.Name) + ": " + v.Name + ",")
	}
	return buf.String()
}

func (f *Func) ParamNames() string {
	parts := make([]string, 0, len(f.Params))
	for _, v := range f.Params {
		name := v.Name
		if isVariadic(v.Type) {
			name = name + "..."
		}
		parts = append(parts, name)
	}
	return strings.Join(parts, ", ")
}

func (f *Func) ResultsString() string {
	s := joinVars(f.Results, ", ", false, false)
	if len(f.Results) > 1 || (f.HasResults() && f.Results[0].Name != "") {
		s = "(" + s + ")"
	}
	return s
}

func (f *Func) HasResults() bool {
	return len(f.Results) > 0
}

type Var struct {
	Name string
	Type string
}

// RenameCollisions finds types that use the same name across different packages (e.g. Client)
// and renames the output stub to include the package name (e.g. SecretsClient).
func RenameCollisions(allInterfaces map[*packages.Package][]*Interface, dstNameCount map[string]int) {
	for name, count := range dstNameCount {
		if count > 1 {
			for _, ifaces := range allInterfaces {
				for _, iface := range ifaces {
					if iface.DstName == name {
						iface.DstName = strings.Title(iface.Pkg.Name) + iface.DstName
					}
				}
			}
		}
	}
}

func joinVars(vars []Var, sep string, public, inStruct bool) string {
	parts := make([]string, 0, len(vars))
	for _, v := range vars {
		name, typ := v.Name, v.Type
		if public {
			name = publicize(name)
		}
		if inStruct && isVariadic(v.Type) {
			typ = "[]" + v.Type[3:]
		}
		parts = append(parts, name+" "+typ)
	}
	return strings.Join(parts, sep)
}

func typeName(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.ArrayType:
		if t.Len == nil {
			return "[]" + typeName(t.Elt)
		} else {
			log.Fatal("typeName: don't know how to handle non-slice arrays yet")
		}
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		return typeName(t.X) + "." + t.Sel.Name
	case *ast.StarExpr:
		return "*" + typeName(t.X)
	default:
		log.Fatalf("typeName: unknown node type: %T", t)
	}

	return ""
}

// TODO: improve this to make some variable names more readable, e.g. "db" -> "DB"
func publicize(name string) string {
	return string(unicode.ToTitle(rune(name[0]))) + name[1:]
}

func isVariadic(typ string) bool {
	return strings.HasPrefix(typ, "...")
}
