// Stubber is a tool to automate the creation of "stubbed" interface implementations.
//
// An interface's stubbed implementation is a struct, satisfying the interface,
// that contains one field for each of the interface's methods. When one of
// these methods is called, it uses the backing field as its implementation, or
// panics if none was defined. This allows the behavior of the stub to be
// modified at run-time in a type-safe way.
//
// For example, given this simple interface:
//
//	type Database interface {
//		// UserName retrieves the name of the user with the provided id.
//		UserName(id int64) (string, error)
//	}
//
// Then its stub would look like this:
//
//	type StubbedDatabase struct {
//		UserNameStub func(id int64) (string, error)
//	}
//
//	func (s *StubbedDatabase) UserName(id int64) (string, error) {
//		if s.UserNameStub == nil {
//			panic("StubbedDatabase.UserName: nil method stub")
//		}
//		return (s.UserNameStub)(id)
//	}
//
// Note that StubbedDatabase implements the Database interface, and that its
// implementation of the UserName method uses the backing field UserNameStub.
//
// Here's an example of how it would be used in a test:
//
//	func TestSomething(t *testing.T) {
//		db := &StubbedDatabase{
//			UserNameStub: func(id int64) (string, error) {
//				return "<username>", nil
//			},
//		}
//
//		// Use db here anywhere a Database is accepted
//	}
//
// Assuming the rest of your code is built around an actual implementation of
// Database, and that your methods take their dependent resources as
// parameters, then this provides an easy way to mock out database calls, but
// in an easy-to-understand, type-safe manner.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/build"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"html/template"
	"io/ioutil"
	"log"
	"path/filepath"
	"strings"

	"golang.org/x/tools/imports"
)

var (
	typeNames = flag.String("type", "", "comma-separated list of type names; must be set")
	output    = flag.String("output", "", "output file name; default srcdir/<pkg>_stubs.go")

	t = template.Must(template.New("").Parse(`// This file was generated by stubber; DO NOT EDIT
	
package {{.Name}}

{{range $interface := .Interfaces}}
type {{.ImplName}} struct {
	{{range .Funcs -}}
	{{.StubName}} func({{.ParamsString}}) {{.ResultsString}}
	{{- end}}
}

{{range .Funcs}}
func (s *{{$interface.ImplName}}) {{.Name}}({{.ParamsString}}) {{.ResultsString}} {
	if s.{{.StubName}} == nil {
		panic("{{$interface.ImplName}}.{{.Name}}: nil method stub")
	}
	{{if .HasResults}}return {{end}}(s.{{.StubName}})({{.ParamNames}})
}
{{end}}

// Compile-time check that the implementation matches the interface.
var _ {{.Name}} = (*{{.ImplName}})(nil)
{{end}}
`))
)

func main() {
	log.SetFlags(0)
	log.SetPrefix("stubber: ")
	flag.Parse()

	// ts := strings.Split(*typeNames, ",")

	// Default to the current directory, but grab the first argument as the dir if it's available.
	dir := "."
	if args := flag.Args(); len(args) > 0 {
		dir = args[0]
	}

	pkg := NewPackage(dir)
	pkg.Check()

	var buf bytes.Buffer
	if err := t.Execute(&buf, pkg); err != nil {
		log.Fatal(err)
	}

	code, err := imports.Process(pkg.Name+"_stubbed.go", buf.Bytes(), nil)
	if err != nil {
		log.Fatalf("cannot process imports: %s", err)
	}

	if *output == "" {
		*output = filepath.Join(dir, pkg.Name+"_stubs.go")
	}
	if *output == "-" {
		fmt.Println(string(code))
	} else {
		if err := ioutil.WriteFile(*output, code, 0644); err != nil {
			log.Fatalf("cannot write file %s: %s", *output, err)
		}
	}
}

type Package struct {
	dir   string
	files []*ast.File
	fs    *token.FileSet

	Name       string
	Interfaces []Interface
}

func NewPackage(directory string) *Package {
	pkg, err := build.Default.ImportDir(directory, 0)
	if err != nil {
		log.Fatalf("cannot process directory %s: %s", directory, err)
	}

	var files []*ast.File
	fs := token.NewFileSet()
	for _, name := range pkg.GoFiles {
		name = filepath.Join(directory, name)
		parsed, err := parser.ParseFile(fs, name, nil, 0)
		if err != nil {
			log.Fatalf("cannot parse file %s: %s", name, err)
		}
		files = append(files, parsed)
	}

	if len(files) == 0 {
		log.Fatalf("%s: no buildable Go files", directory)
	}

	return &Package{
		dir:   directory,
		files: files,
		fs:    fs,
		Name:  pkg.Name,
	}
}

func (p *Package) Check() {
	config := types.Config{Importer: importer.Default()}
	info := types.Info{}
	if _, err := config.Check(p.dir, p.fs, p.files, &info); err != nil {
		log.Fatalf("cannot check package: %s", err)
	}
	for _, f := range p.files {
		ast.Inspect(f, p.genDecl)
	}
}

func (p *Package) genDecl(node ast.Node) bool {
	// fmt.Printf("%T\n", node)
	if decl, ok := node.(*ast.GenDecl); ok && decl.Tok == token.TYPE {
		for _, spec := range decl.Specs {
			tspec := spec.(*ast.TypeSpec)
			itype, ok := tspec.Type.(*ast.InterfaceType)
			if !ok {
				continue
			}
			iface := Interface{Name: tspec.Name.Name}
			for _, method := range itype.Methods.List {
				ftype, ok := method.Type.(*ast.FuncType)
				if !ok {
					continue
				}

				ifunc := Func{Name: method.Names[0].Name}
				if ifunc.Name == "_" {
					continue
				}

				if ftype.Params != nil {
					for _, param := range ftype.Params.List {
						v := Var{Type: typeName(param.Type)}
						if len(param.Names) > 0 {
							v.Name = param.Names[0].Name
						}
						ifunc.Params = append(ifunc.Params, v)
					}
				}

				if ftype.Results != nil {
					for _, result := range ftype.Results.List {
						v := Var{Type: typeName(result.Type)}
						if len(result.Names) > 0 {
							v.Name = result.Names[0].Name
						}
						ifunc.Results = append(ifunc.Results, v)
					}
				}

				iface.Funcs = append(iface.Funcs, ifunc)
			}
			p.Interfaces = append(p.Interfaces, iface)
		}
	}
	return true
}

type Interface struct {
	Name  string
	Funcs []Func
}

func (i *Interface) ImplName() string {
	return "Stubbed" + i.Name
}

type Func struct {
	Name    string
	Params  []Var
	Results []Var
}

func (f *Func) StubName() string {
	return f.Name + "Stub"
}

func (f *Func) ParamsString() string {
	return joinVars(f.Params)
}

func (f *Func) ParamNames() string {
	parts := make([]string, 0, len(f.Params))
	for _, v := range f.Params {
		parts = append(parts, v.Name)
	}
	return strings.Join(parts, ", ")
}

func (f *Func) ResultsString() string {
	s := joinVars(f.Results)
	if len(f.Results) > 1 || (f.HasResults() && f.Results[0].Name != "") {
		s = "(" + s + ")"
	}
	return s
}

func (f *Func) HasResults() bool {
	return len(f.Results) > 0
}

type Var struct {
	Name string
	Type string
}

func joinVars(vars []Var) string {
	parts := make([]string, 0, len(vars))
	for _, v := range vars {
		parts = append(parts, v.Name+" "+v.Type)
	}
	return strings.Join(parts, ", ")
}

func typeName(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.ArrayType:
		if t.Len == nil {
			return "[]" + typeName(t.Elt)
		} else {
			log.Fatal("typeName: don't know how to handle non-slice arrays yet")
		}
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		return typeName(t.X) + "." + t.Sel.Name
	case *ast.StarExpr:
		return "*" + typeName(t.X)
	default:
		log.Fatalf("typeName: unknown node type: %T", t)
	}

	return ""
}
