// Stubber is a tool to automate the creation of "stubbed" interface implementations.
//
// An interface's stubbed implementation is a struct, satisfying the interface,
// that contains one field for each of the interface's methods. When one of
// these methods is called, it uses the backing field as its implementation, or
// panics if none was defined. This allows the behavior of the stub to be
// modified at run-time in a type-safe way, while only requiring you to define
// the methods that will actually be called.
//
// For example, given this simple interface:
//
//	type SessionManager interface {
//		GetUserID(db *sql.DB, username string) (int64, error)
//	}
//
// Then its stub would look like this:
//
//      type StubbedSessionManager struct {
//      	GetUserIDStub  func(db *sql.DB, username string) (int64, error)
//      	getUserIDCalls []struct {
//      		Db       *sql.DB
//      		Username string
//      	}
//      }
//
//      func (s *StubbedSessionManager) GetUserID(db *sql.DB, username string) (int64, error) {
//      	if s.GetUserIDStub == nil {
//      		panic("StubbedSessionManager.GetUserID: nil method stub")
//      	}
//      	s.getUserIDCalls = append(s.getUserIDCalls, struct {
//      		Db       *sql.DB
//      		Username string
//      	}{Db: db, Username: username})
//      	return (s.GetUserIDStub)(db, username)
//      }
//
//      func (s *StubbedSessionManager) GetUserIDCalls() []struct {
//      	Db       *sql.DB
//      	Username string
//      } {
//      	return s.getUserIDCalls
//      }
//
// Note that StubbedSessionManager implements the SessionManager interface, and that its
// implementation of GetUserID()  uses the backing field GetUserIDStub.
//
// Here's an example of how it would be used in a test:
//
//	func TestSomething(t *testing.T) {
//		sm := &StubbedSessionManager{
//			GetUserIDStub: func(db *sql.DB, username string) (int64, error) {
//				return 0, nil // or whatever implementation you want
//			},
//		}
//
//		// Use sm here anywhere a SessionManager is accepted
//	}
//
// Assuming the rest of your code is built around an actual implementation of
// SessionManager, and that your methods take their dependent resources as
// parameters, then this provides an easy way to mock out service calls, but
// in an easy-to-understand, type-safe manner.
//
// See the example folder for more information.
package main

import (
	"bytes"
	"flag"
	"go/format"
	"go/types"
	"html/template"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"unicode"

	"golang.org/x/tools/go/packages"
)

var (
	t = template.Must(template.New("").Parse(`// This file was generated by stubber; DO NOT EDIT

// +build !nostubs
	
package {{.OutputName}}

import (
	{{range $pkg, $empty := .Dependencies}}"{{$pkg}}"
	{{end}}
)

{{range $interface := .Interfaces}}
// {{.ImplName}} is a stubbed implementation of {{if $.External}}{{$.InputName}}.{{end}}{{.Name}}.
type {{.ImplName}} struct {
	{{range .Funcs -}}
	// {{.StubName}} defines the implementation for {{.Name}}.
	{{.StubName}} func{{.ParamsString}} {{.ResultsString}}
	{{.CallsName false}} []{{.ParamsStruct}}
	{{end}}
}

{{range .Funcs}}
// {{.Name}} delegates its behavior to the field {{.StubName}}.
func (s *{{$interface.ImplName}}) {{.Name}}{{.ParamsString}} {{.ResultsString}} {
	if s.{{.StubName}} == nil {
		panic("{{$interface.DstName}}.{{.Name}}: nil method stub")
	}
	s.{{.CallsName false}} = append(s.{{.CallsName false}}, {{.ParamsStruct}}{ {{.ParamsStructValues}} })
	{{if .HasResults}}return {{end}}(s.{{.StubName}})({{.ParamNames}})
}

// {{.CallsName true}} returns a slice of calls made to {{.Name}}. Each element
// of the slice represents the parameters that were provided.
func (s *{{$interface.DstName}}) {{.CallsName true}}() []{{.ParamsStruct}} {
	return s.{{.CallsName false}}
}
{{end}}

// Compile-time check that the implementation matches the interface.
var _ {{if $.External}}{{$.InputName}}.{{end}}{{.Name}} = (*{{.ImplName}})(nil)
{{end}}
`))
)

func main() {
	var (
		outputDir = flag.String("output", "", "path to output directory; '-' will write result to stdout")
	)

	log.SetFlags(0)
	log.SetPrefix("stubber: ")
	flag.Parse()

	var types []string
	if *typeNames != "" {
		types = strings.Split(*typeNames, ",")
	}

	// Default to the current directory, but grab the first argument as the dir if it's available.
	inputDirs := flag.Args()
	if len(inputDirs) == 0 {
		inputDirs = []string{"."}
	}

	var out io.Writer
	if *outputDir == "-" {
		out = os.Stdout
		*outputDir = ""
	} else if *outputDir == "" {
		*outputDir = "."
	}

	Main(types, inputDirs, *outputDir, out)
}

func Main(types, inputDirs []string, outputDir string, out io.Writer) {
	var pkgs []*Package
	for _, inputDir := range inputDirs {
		inputDirInfo, err := os.Stat(inputDir)
		if err != nil {
			log.Fatalf("cannot stat input dir: %s", err)
		}

		if outputDir != "" {
			if err := os.MkdirAll(outputDir, inputDirInfo.Mode()); err != nil {
				log.Fatalf("cannot make output directory: %s", err)
			}
		}

		pkg := NewPackage(inputDir, outputDir)
		pkg.Check(types)
		pkgs = append(pkgs, pkg)
	}

	// Check for duplicate interface names, e.g. "Client"
	defs := make(map[string]int)
	for _, pkg := range pkgs {
		for _, iface := range pkg.Interfaces {
			defs[iface.StubName] += 1
		}
	}
	for name, count := range defs {
		if count <= 1 {
			continue
		}
		for _, pkg := range pkgs {
			for _, iface := range pkg.Interfaces {
				if iface.StubName == name {
					iface.StubName = publicize(pkg.Pkg.Name) + iface.StubName
				}
			}
		}
	}

	var buf bytes.Buffer
	for _, pkg := range pkgs {
		buf.Reset()
		if err := t.Execute(&buf, pkg); err != nil {
			log.Fatal(err)
		}
	}

		newFilename := pkg.Pkg.Name + "_stubs.go"
		code, err := format.Source(buf.Bytes())
		if err != nil {
			log.Fatalf("error formatting stubs: %s", err)
		}

	if out != nil {
		if _, err := out.Write(code); err != nil {
			log.Fatalf("failed to write result: %s", err)
		}
	} else {
		if err := ioutil.WriteFile(filename, code, 0644); err != nil {
			log.Fatalf("failed to write output file %s: %s", filename, err)
		}
	}
}

type Package struct {
	// OutputName is the name of the output package.
	OutputName string
	// InputName is the name of the input package.
	InputName string
	// External is true if the output is in a different package than the
	// input, indicating that the interface name needs to be qualified if
	// referenced.
	External     bool
	Pkg          *packages.Package
	Interfaces   []*Interface
	Dependencies map[string]struct{}
}

func NewPackage(inputDir, outputDir string) *Package {
	pkgs, err := packages.Load(&packages.Config{Mode: packages.LoadAllSyntax, BuildFlags: []string{"-tags=nostubs"}}, inputDir)
	if err != nil {
		panic(err)
	}

	p := &Package{
		InputName:    pkgs[0].Name,
		OutputName:   pkgs[0].Name,
		Pkg:          pkgs[0],
		Dependencies: make(map[string]struct{}),
	}

	if ftype.Results != nil {
		for _, result := range ftype.Results.List {
			if len(result.Names) == 0 {
				ifunc.Results = append(ifunc.Results, Var{Type: TypeName(pkg, result.Type)})
			} else {
				for _, ident := range result.Names {
					ifunc.Results = append(ifunc.Results, Var{
						Type: TypeName(pkg, result.Type),
						Name: ident.Name,
					})
				}
			}
		}
	}
	return ifunc
}

func ImportPath(pkgPath string) string {
	parts := strings.Split(pkgPath, "/")
	for len(parts) > 0 {
		path := strings.Join(parts, "/")
		if _, err := packages.Load(nil, path); err == nil {
			log.Println("package " + pkgPath + " successfully imported")
			return path
		}
		parts = parts[1:]
	}
	log.Fatal("unable to import package: " + pkgPath)
	return ""
}

func (p *Package) Check(ts []string) {
	if p.External {
		p.Dependencies[p.Pkg.PkgPath] = struct{}{}
	}

	for ident, def := range p.Pkg.TypesInfo.Defs {
		if def == nil || !types.IsInterface(def.Type()) {
			continue
		}

		if def.Parent() != p.Pkg.Types.Scope() {
			continue
		}

		// If any type names were specified, make sure this type was included.
		if len(ts) > 0 {
			var include bool
			for _, typ := range ts {
				if typ == ident.Name {
					include = true
					break
				}
			}
			if !include {
				continue
			}
		}

		iface := Interface{
			Name:     ident.Name,
			StubName: ident.Name,
			External: p.External,
		}

		itype := def.Type().Underlying().(*types.Interface)
		for i := 0; i < itype.NumMethods(); i++ {
			method := itype.Method(i)
			if method.Name() == "_" {
				continue
			}

			sig := method.Type().(*types.Signature)
			ifunc := Func{
				Name:     method.Name(),
				Pkg:      p.Pkg.Types,
				Params:   sig.Params(),
				Results:  sig.Results(),
				External: p.External,
			}

			for j := 0; j < ifunc.Params.Len(); j++ {
				if named, ok := indirect(ifunc.Params.At(j).Type()).(*types.Named); ok {
					if pkg := named.Obj().Pkg(); pkg != nil {
						p.Dependencies[pkg.Path()] = struct{}{}
					}
				}
			}

			for j := 0; j < ifunc.Results.Len(); j++ {
				if named, ok := indirect(ifunc.Results.At(j).Type()).(*types.Named); ok {
					if pkg := named.Obj().Pkg(); pkg != nil {
						p.Dependencies[pkg.Path()] = struct{}{}
					}
				}
			}

			iface.Funcs = append(iface.Funcs, ifunc)

		}
		p.Interfaces = append(p.Interfaces, &iface)
	}
}

type Interface struct {
	Name, StubName string
	Funcs          []Func
	External       bool
}

func (i *Interface) ImplName() string {
	if i.External {
		return i.StubName
	}
	return "Stubbed" + i.StubName
}

type Func struct {
	Name     string
	Pkg      *types.Package
	Params   *types.Tuple
	Results  *types.Tuple
	External bool
}

func (f *Func) Qualifier(pkg *types.Package) string {
	if !f.External && pkg == f.Pkg {
		return ""
	}
	return pkg.Name()
}

func (f *Func) StubName() string {
	return f.Name + "Stub"
}

func (f *Func) CallsName(public bool) string {
	if public {
		return f.Name + "Calls"
	}
	return string(unicode.ToLower(rune(f.Name[0]))) + f.Name[1:] + "Calls"
}

func (f *Func) ParamsString() string {
	return types.TypeString(f.Params, f.Qualifier)
}

func (f *Func) ParamsStruct() string {
	var parts []string
	for i := 0; i < f.Params.Len(); i++ {
		param := f.Params.At(i)
		typeString := types.TypeString(param.Type(), f.Qualifier)
		parts = append(parts, publicize(param.Name())+" "+typeString)
	}
	return "struct{" + strings.Join(parts, ";") + "}"
}

func (f *Func) ParamsStructValues() string {
	var buf bytes.Buffer
	for i := 0; i < f.Params.Len(); i++ {
		name := f.Params.At(i).Name()
		buf.WriteString(publicize(name) + ": " + name + ",")
	}
	return buf.String()
}

func (f *Func) ParamNames() string {
	var parts []string
	for i := 0; i < f.Params.Len(); i++ {
		parts = append(parts, f.Params.At(i).Name())
	}
	return strings.Join(parts, ", ")
}

func (f *Func) ResultsString() string {
	return types.TypeString(f.Results, f.Qualifier)
}

func (f *Func) HasResults() bool {
	return f.Results.Len() != 0
}

// TODO: improve this to make some variable names more readable, e.g. "db" -> "DB"
func publicize(name string) string {
	if len(name) == 0 {
		panic("empty name found, make sure all your interface parameters have a name!")
	}
	return string(unicode.ToTitle(rune(name[0]))) + name[1:]
}

// indirect returns the type that t points to. If it's not a pointer it
// returns its argument.
func indirect(t types.Type) types.Type {
	for {
		if ptype, ok := t.(*types.Pointer); ok {
			t = ptype.Elem()
		} else {
			return t
		}
	}
}
